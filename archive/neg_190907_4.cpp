/*
今天，是游戏展会的最后天了。 程序员小明终于结束了他的工
作，来到展会参观与游玩游戏。展会会为每位参加者发放一张格
子片，每玩过个展位的游戏，就可以在某个格子上盖上一个
印章。小明领了卡片，没有听取更详细的说明，就冲进了会场畅
玩各款游戏。
但当快乐的一天结束，小明要离开会场的时候才发现了一个问
题:与会者可以从卡片上剪下个正方形十字图家， 通过机器的
扫描后，能够兑换稀有的游戏周边!而且正方形的边长越大，就
能换到越稀有的周边。
但由于是机器扫描，所以要求剪下来的图案有着严格的要求:现
场发放的卡片是一张N行M列格子组成的卡片，每个格子都是长宽
为1个单位的正方形卡片。剪下来的区域必须是个正方形， 且必
须沿着格子的边剪下来(即不能从格子中问剪开) .对于十字图
室，也有严格的要求:设剪下来的区域边长为3K (k为正整数)，
那么剪下来的区域可以看作由9个k*K个格子的正方形区域组成。
而当且仅当左上、右上、左下、右下的k*k个格子完全空白(没有
盖上任何印章)，其他区域每一个格子都必须盖 上印章，这才算一
个合格的十字图家。
小明游玩了非常多的游戏，印章完全是随便盖的，如何在这乱七
八糟的图案中找一个最大的可用区域兑换奖励成了一 个难题。他
此时已经急坏了，大脑宕机，于是只能求助心行的你。
一些关于合法十字图案的详细说明如下。

输入描述:
每个输入数据包含多个测试点。第一行为测试组数t。
接下来是 t 组测试点数据 (0 < t <= 10)。

对于每组测试点:
第一行为两个正整数n，m,表示小明的卡片有行列(O
n,m <= 2000)。行的编号从上到下，列的编号从左到右。即
最上方一行为第一行，最左边一列为第一列。
接下来n行，每行都是长度力m的01串，第i行的第5个字符若为
0,表示小明卡片上n行m列的这个格子没有盖印章，而为1时则
说明被盖上印章。
值得说明的是:小明一个格子最多只会盖一次印章，而且这个
印章位置不会盖歪导致跨多个格子的情况。

输出描述:
按顺序输出每组测试点的答案。
对于每组测试点:
输出一行，包含四个由空格隔开的正整数a，b, C, d。表示
在小明卡片上找到的最大正方形区域，其左上角格子坐标为a行
b列，右下角坐标为c行d列。如果没有一个合法的正方形区
域，a=b=c=d=-1。如果有多个大小相同的区域，输出a最小的
那个，a相等则输出b最小的那个。

3
3 3
111
000
111
6 6
010010
111111
010010
010010
111111
010010
8 8
01000001
11100001
01001100
11001100
00111111
00111111
00001100
11001100

-1 -1 -1 -1
1 1 3 3
3 3 8 8
*/

#include <cstdio>
using namespace std;

char grid[2001][2001];

bool all_zero(int r, int c, int width) {
    for (int i = r; i < r + width; ++i) {
        for (int j = c; j < c + width; ++j) {
            if (grid[i][j] != '0') {
                return false;
            }
        }
    }
    return true;
}

bool is_ok(int r, int c, int width) {
    int cnt0 = 0;
    int k = width / 3;
    for (int i = r; i < r + width; ++i) {
        for (int j = c; j < c + width; ++j) {
            cnt0 += grid[i][j] == '0';
        }
    }
    if (cnt0 != 4 * k * k) {
        return false;
    }
    return all_zero(r, c, k) && all_zero(r + 2 * k, c, k) &&
           all_zero(r, c + 2 * k, k) && all_zero(r + 2 * k, c + 2 * k, k);
}

int main() {
    int T;
    scanf("%d", &T);
    while (T--) {
        int n, m;
        scanf("%d %d", &n, &m);
        for (int i = 0; i < n; ++i) {
            scanf("%s", grid[i]);
        }

        int maxl = 3;
        int r = -2, c = -2;
        for (int i = 0; i <= n - maxl; ++i) {
            for (int j = 0; j <= m - maxl; ++j) {
                if (is_ok(i, j, maxl)) {
                    r = i;
                    c = j;
                    i = -1;
                    j = 0;
                    maxl += 3;
                    break;
                }
            }
        }
        maxl -= 3;
        if (r == -2) {
            maxl = 1;
        }
        printf("%d %d %d %d\n", r + 1, c + 1, r + maxl, c + maxl);
    }
    return 0;
}
